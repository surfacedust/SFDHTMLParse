/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef url_TYPES_H
#define url_TYPES_H

#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>



namespace radar {

struct Status {
  enum type {
    UNLOAD = 0,
    TODO = 1,
    DOING = 2,
    OK = 200,
    BAD_REQUEST = 400,
    UNAUTHORIZED = 401,
    PAYMENT_REQUIRED = 402,
    FORBIDDEN = 403,
    NOT_FOUND = 404,
    METHOD_NOT_ALLOWED = 405,
    NOT_ACCEPTABLE = 406,
    PROXY_AUTHENTICATION_REQUIRED = 407,
    REQUEST_TIMEOUT = 408,
    CONFLIICT = 409,
    GONE = 410,
    LENGTH_REQUIRED = 411,
    PRECONDITION_FAILED = 412,
    REQUEST_ENTITY_TOO_LARGE = 413,
    REQUEST_URI_TOO_LONG = 414,
    UNSUPPORTED_MEDIA_TYPE = 415,
    REQUESTED_RANGE_NOT_SATISFIABLE = 416,
    EXPECTATION_FAILED = 417,
    INTERNAL_SERVER_ERROR = 500,
    NOT_IMPLEMENTED = 501,
    BAD_GATEWAY = 502,
    SERVICE_UNAVAILABLE = 503,
    GATEWAY_TIMEOUT = 504,
    HTTP_VERSION_NOT_SUPPORTED = 505
  };
};

extern const std::map<int, const char*> _Status_VALUES_TO_NAMES;

struct ExpandWay {
  enum type {
    BY_SEED_DIRECTORY = 0,
    BY_SEED_ROOT = 1,
    BY_SEED_DOMAIN = 2,
    BY_NOLIMIT = 3
  };
};

extern const std::map<int, const char*> _ExpandWay_VALUES_TO_NAMES;


class Url {
 public:

  static const char* ascii_fingerprint; // = "595AB1B36D9E64A40A0D544FD479C851";
  static const uint8_t binary_fingerprint[16]; // = {0x59,0x5A,0xB1,0xB3,0x6D,0x9E,0x64,0xA4,0x0A,0x0D,0x54,0x4F,0xD4,0x79,0xC8,0x51};

  Url() : id(0), seed_id(0), parent_id(0), url(""), weight(0), depth(0), expend_way((ExpandWay::type)0), status((Status::type)0) {
  }

  virtual ~Url() throw() {}

  int64_t id;
  int64_t seed_id;
  int64_t parent_id;
  std::string url;
  double weight;
  int32_t depth;
  ExpandWay::type expend_way;
  Status::type status;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_seed_id(const int64_t val) {
    seed_id = val;
  }

  void __set_parent_id(const int64_t val) {
    parent_id = val;
  }

  void __set_url(const std::string& val) {
    url = val;
  }

  void __set_weight(const double val) {
    weight = val;
  }

  void __set_depth(const int32_t val) {
    depth = val;
  }

  void __set_expend_way(const ExpandWay::type val) {
    expend_way = val;
  }

  void __set_status(const Status::type val) {
    status = val;
  }

  bool operator == (const Url & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(seed_id == rhs.seed_id))
      return false;
    if (!(parent_id == rhs.parent_id))
      return false;
    if (!(url == rhs.url))
      return false;
    if (!(weight == rhs.weight))
      return false;
    if (!(depth == rhs.depth))
      return false;
    if (!(expend_way == rhs.expend_way))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const Url &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Url & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class FailedUrl {
 public:

  static const char* ascii_fingerprint; // = "C119CA949C6BAA7DFD53C57F53D6311C";
  static const uint8_t binary_fingerprint[16]; // = {0xC1,0x19,0xCA,0x94,0x9C,0x6B,0xAA,0x7D,0xFD,0x53,0xC5,0x7F,0x53,0xD6,0x31,0x1C};

  FailedUrl() : id(0), url(""), status((Status::type)0) {
  }

  virtual ~FailedUrl() throw() {}

  int64_t id;
  std::string url;
  Status::type status;

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_url(const std::string& val) {
    url = val;
  }

  void __set_status(const Status::type val) {
    status = val;
  }

  bool operator == (const FailedUrl & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(url == rhs.url))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const FailedUrl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FailedUrl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class SuccessUrl {
 public:

  static const char* ascii_fingerprint; // = "6B0CD68886A371B59CE1B9EDCF067801";
  static const uint8_t binary_fingerprint[16]; // = {0x6B,0x0C,0xD6,0x88,0x86,0xA3,0x71,0xB5,0x9C,0xE1,0xB9,0xED,0xCF,0x06,0x78,0x01};

  SuccessUrl() : seed_id(0), id(0), url("") {
  }

  virtual ~SuccessUrl() throw() {}

  int64_t seed_id;
  int64_t id;
  std::string url;

  void __set_seed_id(const int64_t val) {
    seed_id = val;
  }

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_url(const std::string& val) {
    url = val;
  }

  bool operator == (const SuccessUrl & rhs) const
  {
    if (!(seed_id == rhs.seed_id))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(url == rhs.url))
      return false;
    return true;
  }
  bool operator != (const SuccessUrl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SuccessUrl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class NewUrl {
 public:

  static const char* ascii_fingerprint; // = "8C845A3AAF3585B0F962B641E472EE17";
  static const uint8_t binary_fingerprint[16]; // = {0x8C,0x84,0x5A,0x3A,0xAF,0x35,0x85,0xB0,0xF9,0x62,0xB6,0x41,0xE4,0x72,0xEE,0x17};

  NewUrl() : url(""), weight(0), depth(0) {
  }

  virtual ~NewUrl() throw() {}

  std::string url;
  double weight;
  int32_t depth;

  void __set_url(const std::string& val) {
    url = val;
  }

  void __set_weight(const double val) {
    weight = val;
  }

  void __set_depth(const int32_t val) {
    depth = val;
  }

  bool operator == (const NewUrl & rhs) const
  {
    if (!(url == rhs.url))
      return false;
    if (!(weight == rhs.weight))
      return false;
    if (!(depth == rhs.depth))
      return false;
    return true;
  }
  bool operator != (const NewUrl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NewUrl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class ParserUrl {
 public:

  static const char* ascii_fingerprint; // = "7805498CEE328F6C5C70B7A66234FE3A";
  static const uint8_t binary_fingerprint[16]; // = {0x78,0x05,0x49,0x8C,0xEE,0x32,0x8F,0x6C,0x5C,0x70,0xB7,0xA6,0x62,0x34,0xFE,0x3A};

  ParserUrl() {
  }

  virtual ~ParserUrl() throw() {}

  SuccessUrl succ_url;
  std::vector<NewUrl>  new_urls;

  void __set_succ_url(const SuccessUrl& val) {
    succ_url = val;
  }

  void __set_new_urls(const std::vector<NewUrl> & val) {
    new_urls = val;
  }

  bool operator == (const ParserUrl & rhs) const
  {
    if (!(succ_url == rhs.succ_url))
      return false;
    if (!(new_urls == rhs.new_urls))
      return false;
    return true;
  }
  bool operator != (const ParserUrl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ParserUrl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

} // namespace

#endif
